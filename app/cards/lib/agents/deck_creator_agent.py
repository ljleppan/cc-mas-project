import operator
import numpy as np
from random import choice
from cards.models import *
from collections import defaultdict
from sklearn.decomposition import NMF
import matplotlib.pyplot as plt
import pandas as pd
from math import sqrt

class DeckCreatorAgent:
    """
    :class:`DeckCreatorAgent` builds a fairly balanced deck of 30 cards from cards
    generated by instances of :class:`CardCreatorAgent` that have passed the
    fairness and novelty checks of :class:`Gatekeeper` agents.

    A :class:`DeckCreatorAgent` values each attack and health point as 0.5 mana's
    worth. This is known as the "vanilla test" and can be used to quickly evaluate
    cards manually. The agent also has approximate knowledge of mechanic values
    (rounded to nearest 0.5). It evaluates cards based on these two values, weighting
    that evaluation by a need to approximate a good "mana curve".

    The mana curve is a conceptual rule that essentially says that a deck should
    have more "cheap" minions than "expensive" minions -- so that the player has
    something to play during the first few turns -- but also have some more expensive
    minions so that the player has a fighting chance in the end game.

    The agent can use three different evaluation schemes: in the default scheme,
    health and attack are valued equivalently. In the offesive-heavy scheme, attack is
    valued more and positively valued mechanics containing the words "damage" or
    "windfury" are overvalued. In the defensive scheme health and positive mechanics
    containing the words "heal" and "taunt" are overvalued. The scheme is chosen by the
    `evaluator` paremeter.
    """

    def __init__(self, env, gatekeepers, evaluator):
        """
        Constructs a new :class:`DeckCreatorAgent`

        :param env: The environment this :class:`DeckCreatorAgent` lives in.
        :param gatekeepers: The :class:`Gatekeeper` this agent receives cards from.
        :param evaluator: Evaluation scheme to use when evaluating cards.
        """
        self._env = env
        self._gatekeepers = gatekeepers
        self._evaluator = evaluator

    def act(self):
        """
        Constructs a deck of 30 cards. Cards are evaluated as detailed above in
        the class's description.

        The cards are picked in 30 rounds. In each round, each :class:`Gatekeeper`
        proposes one card, the winner of which is added to the deck. The rest
        are discarded.

        The included cards are broadcasted to all :class:`Gatekeeper` agents and
        through them to all :class:`CardCreatorAgent` instances after each pick.
        """
        deck = []
        for _ in range(30):
            choices = [agent.act() for agent in self._gatekeepers]
            print("DeckCreator: Received {} cards from gatekeepers: {}".format(len(choices), choices))
            choices = [(
                            c,
                            self._evaluator.evaluate(c) * (1 + self._evaluate_mana_curve(c, deck))
                        )
                        for c in choices]
            choices.sort(key=operator.itemgetter(1), reverse=True)
            winner = choices[0]
            deck.append(winner[0])
            print("DeckCreator: Determined best card at value={}: {}".format(winner[1], winner[0]))
            print("DeckCreator: Informing GateKeepers of winner")
            (agent.remember(card) for agent in self._env.gatekeepers)
        curve = [card['mana'] for card in deck]
        curve.sort()
        print("DeckCreator: Created deck with mana curve", curve)
        deck.sort(key=operator.itemgetter('mana'))
        return deck

    def _evaluate_mana_curve(self, card, previous_cards):
        curve = [card['mana'] for card in previous_cards]

        lows = 0
        meds = 0
        highs = 0
        for m in range(0, 5):
            lows += curve.count(m)
        for m in range(5, 8):
            meds += curve.count(m)
        for m in range(8, 11):
            highs += curve.count(m)

        target_highs = 5
        target_meds = 10
        target_lows = 15

        curve_fit = 0
        if card['mana'] in range(0, 5):
            curve_fit = 1 - (lows / target_lows)
        if card['mana'] in range(5, 8):
            curve_fit = 1 - (meds / target_meds)
        if card['mana'] in range(8, 11):
            curve_fit = 1 - (highs / target_highs)


        curve_weight = 5 * (len(curve) / 30)
        curve_fit *= curve_weight
        print("DeckCreator: Evaluated {} ({} mana) as fitting the mana curve worth {}, with curve weigth {}".format(card['name'], card['mana'], curve_fit, curve_weight))
        return curve_fit


class DefaultEvaluator:
    """
    An evaluator that has no particular bias. Health and attack are seen as
    equally valuable, mechanic values are rounded to nearest 0.5.
    """

    def evaluate(self, card):
        value = (card['attack'] + card['health']) / 2
        for mechanic, id, effectsize in card['mechanics']:
            db_mechanic = Mechanic.objects.get(pk=id)
            mechanic_value = db_mechanic.value * effectsize
            mechanic_value = round(mechanic_value * 2) / 2 # Round to nearest 0.5
            value += mechanic_value
        print("DeckCreator: Card quality of {}: {}".format(card['name'], value))
        return value

class DefensiveEvaluator:
    """
    An evaluator with bias on defense. Health is seen as more valuable than attack,
    "taunt" and "heal" mechanics are overvalued when positive.
    """

    def evaluate(self, card):
        value = ((card['attack'] * 0.75) + (card['health']*1.25)) / 2
        for mechanic, id, effectsize in card['mechanics']:
            db_mechanic = Mechanic.objects.get(pk=id)
            mechanic_value = db_mechanic.value * effectsize
            mechanic_value = round(mechanic_value * 2) / 2 # Round to nearest 0.5
            value += mechanic_value
            if "taunt" in db_mechanic.name.lower() or "heal" in db_mechanic.name.lower():
                if db_mechanic.value > 0:
                    print("DeckCreator: Overvaluing positive taunt or heal")
                    mechanic_value += 0.25
            value += mechanic_value
        print("DeckCreator: Card quality of {}: {}".format(card['name'], value))
        return value

class OffensiveEvaluator:
    """
    An evaluator with bias on offense. Attack is seen as more valuable than health,
    "windfury" and "damage" mechanics are overvalued when positive.
    """

    def evaluate(self, card):
        value = ((card['attack'] * 1.25) + (card['health']*0.75)) / 2
        for mechanic, id, effectsize in card['mechanics']:
            db_mechanic = Mechanic.objects.get(pk=id)
            mechanic_value = db_mechanic.value * effectsize
            mechanic_value = round(mechanic_value * 2) / 2 # Round to nearest 0.5
            value += mechanic_value
            if "windfury" in db_mechanic.name.lower() or "damage" in db_mechanic.name.lower():
                if db_mechanic.value > 0:
                    print("DeckCreator: Overvaluing windfury or damage")
                    mechanic_value += 0.25
            if "can't attack" in db_mechanic.name.lower():
                print("DeckCreator: Undervaluing ''can't attack''")
                mechanic_value -= 0.25
            value += mechanic_value
        print("DeckCreator: Card quality of {}: {}".format(card['name'], value))
        return value

class CollaborativeEvaluator:
    """
    An evaluator that uses collaborative filtering to build the deck. The theory
    is that by using an inspiring set of decks already created, it is possible
    to select cards that mesh well.
    """
    def load_mech_matrix(self):
        mech_matrix = pd.DataFrame.from_csv("mechanic_matrix.csv")
        mech_matrix.index = range(len(mech_matrix))


    def sim_distance(self, mechs, deck1, deck2):
    	#Get the list of shared mechs
    	similar = {}
    	for item in mechs[deck1]:
    		if item in mechs[deck2]:
    			similar[item] = 1

    	#if they have no mechanics in common, return 0.
    	if len(similar) == 0:
    		return 0

    	#Add up the squares of all differences
    	sum_of_squares = sum([pow(mechs[deck1][item]-mechs[deck2][item],2) \
        for item in mechs[deck1] if item in mechs[deck2]])

    	return 1 / (1 + sum_of_squares)


    #Returns the Pearson correlation coefficient for deck1 and deck2
    def sim_pearson(self, mechs,deck1,deck2):
        # Find card mechanics that co-appear in decks
    	similar = {}
    	for item in mechs[deck1]:
    		if item in mechs[deck2]:
    			similar[item] = 1

    	#if  in common, return 0
    	if len(similar) == 0:
    		return 0
    	n = len(similar)

    	#sum of all deck mechanic weights
    	sum1 = sum([mechs[deck1][it] for it in similar])
    	sum2 = sum([mechs[deck2][it] for it in similar])

    	#Sum of the squares
    	sum1Sq = sum([pow(mechs[deck1][it],2) for it in similar])
    	sum2Sq = sum([pow(mechs[deck2][it],2) for it in similar])

    	#Sum of the products
    	pSum = sum([mechs[deck1][it] * mechs[deck2][it] for it in similar])

    	#Calculate r (Pearson score)
    	num = pSum - (sum1 * sum2/n)
    	den = sqrt((sum1Sq - pow(sum1,2)/n) * (sum2Sq - pow(sum2,2)/n))
    	if den == 0:
    		return 0

    	r = num/den

    	return r

    #Returns the best matches for cards in the pool
    def topMatches(self, mechs,card,n=5):
    	scores = [(self.sim_pearson(mechs,card,other),other)
    				for other in mechs if other != card]
    	scores.sort()
    	scores.reverse()
    	return scores[0:n]


    #Gets recommendations for a card by using a weighted average of cards in the pool.
     """
    def getRecommendations(self,mechs,card):
    	totals = {}
    	simSums = {}
    	for other in mechs:
    		#don't compare me to myself
    		if other == card:
    			continue
    		sim = self.sim_pearson(mechs,card,other)

    		#ignore scores of zero or lower
    		if sim <= 0:
    			continue
    		for item in mechs[other]:
    			#only score books i haven't seen yet
    			if item not in mechs[card] or mechs[card][item] == 0:
    				#Similarity * score
    				totals.setdefault(item,0)
    				totals[item] += mechs[other][item] * sim
    				#Sum of similarities
    				simSums.setdefault(item,0)
    				simSums[item] += sim

    	#Create the normalized list
    	rankings = [(total/simSums[item],item) for item,total in totals.items()]

    	#Return the sorted list
    	rankings.sort()
    	rankings.reverse()
    	return rankings
    """


    #Function to transform card, item - > Item, card
    def transformmechs(self, mechs):
    	results = {}
    	for card in mechs:
    		for item in mechs[card]:
    			results.setdefault(item,{})

    			#Flip item and card
    			results[item][card] = mechs[card][item]
    	return results
